/**
 * CultureCart API Services
 * High-level API functions for frontend integration with Firebase and PostgreSQL backend
 */

import {
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signInWithPopup,
  GoogleAuthProvider,
  signOut,
  updateProfile,
  sendPasswordResetEmail,
  User as FirebaseUser,
} from 'firebase/auth';
import {
  doc,
  setDoc,
  getDoc,
  updateDoc,
  collection,
  query,
  where,
  getDocs,
  serverTimestamp,
} from 'firebase/firestore';
import { auth, db } from '@/config/firebase';
import { User, UserRole } from '@/stores/authStore';

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001';

// ==========================================
// FIREBASE AUTHENTICATION SERVICE
// ==========================================

const googleProvider = new GoogleAuthProvider();
googleProvider.setCustomParameters({
  prompt: 'select_account'
});
// Add required scopes
googleProvider.addScope('email');
googleProvider.addScope('profile');

export interface CreateUserData {
  email: string;
  password: string;
  name: string;
  role: UserRole;
  metadata?: {
    craftType?: string;
    experience?: number;
    location?: string;
    portfolio?: string;
    businessName?: string;
    description?: string;
  };
}

export class FirebaseAuthService {
  static async createUser(userData: CreateUserData): Promise<User> {
    try {
      const userCredential = await createUserWithEmailAndPassword(
        auth,
        userData.email,
        userData.password
      );
      const firebaseUser = userCredential.user;

      await updateProfile(firebaseUser, {
        displayName: userData.name,
      });

      const userDoc: User = {
        id: firebaseUser.uid,
        email: firebaseUser.email || '',
        name: userData.name,
        role: userData.role,
        createdAt: new Date().toISOString(),
        lastLoginAt: new Date().toISOString(),
        profileComplete: true,
        onboardingCompleted: false, // Set to false initially for proper onboarding flow
        ...(userData.metadata && { metadata: userData.metadata }), // Only include metadata if it exists
      };

      // Filter out undefined values before saving to Firebase
      const cleanUserDoc = Object.fromEntries(
        Object.entries({
          ...userDoc,
          createdAt: serverTimestamp(),
          lastLoginAt: serverTimestamp(),
        }).filter(([_, value]) => value !== undefined)
      );

      await setDoc(doc(db, 'users', firebaseUser.uid), cleanUserDoc);

      return userDoc;
  }

  static async signInWithEmail(email: string, password: string): Promise<User> {
    try {
      const userCredential = await signInWithEmailAndPassword(auth, email, password);
      const firebaseUser = userCredential.user;

      const userDoc = await getDoc(doc(db, 'users', firebaseUser.uid));
      
      if (userDoc.exists()) {
        const userData = userDoc.data() as User;
        await updateDoc(doc(db, 'users', firebaseUser.uid), {
          lastLoginAt: serverTimestamp(),
        });
        return { ...userData, lastLoginAt: new Date().toISOString() };
      } else {
        const userData: User = {
          id: firebaseUser.uid,
          email: firebaseUser.email || '',
          name: firebaseUser.displayName || 'User',
          role: 'buyer',
          createdAt: new Date().toISOString(),
          lastLoginAt: new Date().toISOString(),
          profileComplete: false,
          onboardingCompleted: false,
        };
        
        await setDoc(doc(db, 'users', firebaseUser.uid), {
          ...userData,
          createdAt: serverTimestamp(),
          lastLoginAt: serverTimestamp(),
        });
        
        return userData;
      }
  }

  static async signInWithGoogle(): Promise<User> {
    try {
      const result = await signInWithPopup(auth, googleProvider);
      const firebaseUser = result.user;

      const userDoc = await getDoc(doc(db, 'users', firebaseUser.uid));
      
      if (userDoc.exists()) {
        const userData = userDoc.data() as User;
        await updateDoc(doc(db, 'users', firebaseUser.uid), {
          lastLoginAt: serverTimestamp(),
        });
        return { ...userData, lastLoginAt: new Date().toISOString() };
      } else {
        const userData: User = {
          id: firebaseUser.uid,
          email: firebaseUser.email || '',
          name: firebaseUser.displayName || firebaseUser.email?.split('@')[0] || 'User',
          role: 'buyer',
          createdAt: new Date().toISOString(),
          lastLoginAt: new Date().toISOString(),
          profileComplete: false,
          onboardingCompleted: false,
        };
        
        await setDoc(doc(db, 'users', firebaseUser.uid), {
          ...userData,
          createdAt: serverTimestamp(),
          lastLoginAt: serverTimestamp(),
        });
        
        return userData;
      }
    } catch (error: any) {
      console.error('Firebase Google signIn error:', error);
      
      // Handle specific Google Sign-In errors
      if (error.code === 'auth/popup-closed-by-user') {
        throw new Error('Sign-in was cancelled. Please try again.');
      } else if (error.code === 'auth/popup-blocked') {
        throw new Error('Pop-up was blocked by your browser. Please allow pop-ups and try again.');
      } else if (error.code === 'auth/cancelled-popup-request') {
        throw new Error('Another sign-in attempt is already in progress.');
      } else if (error.code === 'auth/unauthorized-domain') {
        throw new Error('This domain is not authorized for Google Sign-In. Please contact support.');
      } else if (error.code === 'auth/operation-not-allowed') {
        throw new Error('Google Sign-In is not enabled. Please contact support.');
      } else {
        throw new Error(error.message || 'Google Sign-In failed. Please try again.');
      }
    }
  }

  static async signOut(): Promise<void> {
    try {
      await signOut(auth);
  }


  }


    try {
      await signOut(auth);
  }

  static async getUserData(uid: string): Promise<User | null> {
    try {
      const userDoc = await getDoc(doc(db, 'users', uid));
      return userDoc.exists() ? (userDoc.data() as User) : null;
  }

  static async updateUserData(uid: string, updates: Partial<User>): Promise<void> {
    try {
      await updateDoc(doc(db, 'users', uid), {
        ...updates,
        lastLoginAt: serverTimestamp(),
      });
  }
}

// ==========================================
// HTTP CLIENT UTILITIES
// ==========================================

class ApiClient {
  private baseURL: string;

  constructor(baseURL: string) {
    this.baseURL = baseURL;
  }

  private async request(endpoint: string, options: RequestInit = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const token = localStorage.getItem('culturecart_token');

    const config: RequestInit = {
      headers: {
        'Content-Type': 'application/json',
        ...(token && { Authorization: `Bearer ${token}` }),
        ...options.headers,
      },
      ...options,
    };

    try {
      const response = await fetch(url, config);
      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || `HTTP error! status: ${response.status}`);
      }

      return data;
  }

  async get(endpoint: string) {
    return this.request(endpoint, { method: 'GET' });
  }

  async post(endpoint: string, data?: any) {
    return this.request(endpoint, {
      method: 'POST',
      body: data ? JSON.stringify(data) : undefined,
    });
  }

  async put(endpoint: string, data?: any) {
    return this.request(endpoint, {
      method: 'PUT',
      body: data ? JSON.stringify(data) : undefined,
    });
  }

  async delete(endpoint: string) {
    return this.request(endpoint, { method: 'DELETE' });
  }
}

const apiClient = new ApiClient(API_BASE_URL);

// ==========================================
// AUTHENTICATION & USER MANAGEMENT
// ==========================================

export class AuthService {
  static async signUp(email: string, password: string, userData: any) {
    try {
      const response = await apiClient.post('/api/auth/register', {
        email,
        password,
        ...userData,
      });

      return response.data;
  }

  static async signIn(email: string, password: string) {
    try {
      const response = await apiClient.post('/api/auth/login', {
        email,
        password,
      });

      return response.data;
  }

  static async getCurrentUser() {
    try {
      const response = await apiClient.get('/api/auth/me');
      return response.data;
  }

  static async updateUserProfile(userId: string, updates: any) {
    try {
      const response = await apiClient.put(`/api/users/${userId}`, updates);
      return response.data;
  }

  static async completeOnboarding(userId: string, onboardingData: any) {
    try {
      const response = await apiClient.put(`/api/users/${userId}`, {
        metadata: {
          onboardingCompleted: true,
          location: onboardingData.location,
        },
        preferences: {
          language: onboardingData.language,
        },
      });

      return response.data;
  }

  static async logout() {
    try {
      await apiClient.post('/api/auth/logout');
  }
}

// ==========================================
// ARTISAN MANAGEMENT
// ==========================================

export class ArtisanService {
  static async getFeaturedArtisans(limit = 12) {
    try {
      const response = await apiClient.get(`/api/artisans?featured=true&limit=${limit}`);
      return response.data;
  }

  static async searchArtisans(query: {
    craftType?: string;
    state?: string;
    district?: string;
    minRating?: number;
    limit?: number;
  }) {
    try {
      const params = new URLSearchParams();
      if (query.craftType) params.append('craft_type', query.craftType);
      if (query.state) params.append('state', query.state);
      if (query.district) params.append('district', query.district);
      if (query.minRating) params.append('min_rating', query.minRating.toString());
      if (query.limit) params.append('limit', query.limit.toString());

      const response = await apiClient.get(`/api/artisans?${params.toString()}`);
      return response.data;
  }

  static async getArtisanProfile(artisanId: string) {
    try {
      const response = await apiClient.get(`/api/artisans/${artisanId}`);
      return response.data;
  }

  static async getArtisanProducts(artisanId: string, status = 'published') {
    try {
      const response = await apiClient.get(`/api/products/artisan/${artisanId}?status=${status}`);
      return response.data;
  }

  static async updateArtisanProfile(artisanId: string, updates: any) {
    try {
      const response = await apiClient.put(`/api/artisans/${artisanId}`, updates);
      return response.data;
  }

  static async getArtisanStats(artisanId: string) {
    try {
      const response = await apiClient.get(`/api/artisans/${artisanId}/stats`);
      return response.data;
  }
}

// ==========================================
// PRODUCT MANAGEMENT
// ==========================================

export class ProductService {
  static async getFeaturedProducts(limit = 16) {
    try {
      const response = await apiClient.get(`/api/products?featured=true&limit=${limit}`);
      return response.data;
  }

  static async searchProducts(query: {
    searchTerm?: string;
    category?: string;
    craftTradition?: string;
    minPrice?: number;
    maxPrice?: number;
    state?: string;
    sortBy?: 'price_asc' | 'price_desc' | 'rating' | 'newest' | 'popular';
    limit?: number;
  }) {
    try {
      const params = new URLSearchParams();
      if (query.searchTerm) params.append('search', query.searchTerm);
      if (query.category) params.append('category', query.category);
      if (query.craftTradition) params.append('craft_tradition', query.craftTradition);
      if (query.minPrice) params.append('min_price', query.minPrice.toString());
      if (query.maxPrice) params.append('max_price', query.maxPrice.toString());
      if (query.state) params.append('state', query.state);
      if (query.sortBy) params.append('sort_by', query.sortBy);
      if (query.limit) params.append('limit', query.limit.toString());

      const response = await apiClient.get(`/api/products?${params.toString()}`);
      return response.data;
  }

  static async getProductDetails(productId: string) {
    try {
      const response = await apiClient.get(`/api/products/${productId}`);
      return response.data;
  }

  static async getSimilarProducts(productId: string, category: string, craftTradition: string, limit = 8) {
    try {
      const params = new URLSearchParams({
        category,
        craft_tradition: craftTradition,
        limit: limit.toString(),
      });

      const response = await apiClient.get(`/api/products?${params.toString()}`);
      return response.data.filter((product: any) => product.productId !== productId);
  }

  static async createProduct(productData: any) {
    try {
      const response = await apiClient.post('/api/products', productData);
      return response.data;
  }

  static async updateProduct(productId: string, updates: any) {
    try {
      const response = await apiClient.put(`/api/products/${productId}`, updates);
      return response.data;
  }

  static async deleteProduct(productId: string) {
    try {
      const response = await apiClient.delete(`/api/products/${productId}`);
      return response;
  }
}

// ==========================================
// ORDER MANAGEMENT
// ==========================================

export class OrderService {
  static async createOrder(orderData: any) {
    try {
      const response = await apiClient.post('/api/orders', orderData);
      return response.data;
  }

  static async getUserOrders(status?: string, limit = 50) {
    try {
      const params = new URLSearchParams();
      if (status) params.append('status', status);
      params.append('limit', limit.toString());

      const response = await apiClient.get(`/api/orders?${params.toString()}`);
      return response.data;
  }

  static async getOrderDetails(orderId: string) {
    try {
      const response = await apiClient.get(`/api/orders/${orderId}`);
      return response.data;
  }

  static async updateOrderStatus(orderId: string, status: string, trackingNumber?: string) {
    try {
      const response = await apiClient.put(`/api/orders/${orderId}/status`, {
        status,
        trackingNumber,
      });
      return response.data;
  }

  static async cancelOrder(orderId: string) {
    try {
      const response = await apiClient.put(`/api/orders/${orderId}/cancel`);
      return response;
  }
}

// ==========================================
// REVIEW MANAGEMENT
// ==========================================

export class ReviewService {
  static async getProductReviews(productId: string, limit = 50) {
    try {
      const response = await apiClient.get(`/api/reviews/product/${productId}?limit=${limit}`);
      return response.data;
  }

  static async createReview(reviewData: any) {
    try {
      const response = await apiClient.post('/api/reviews', reviewData);
      return response.data;
  }

  static async updateReview(reviewId: string, updates: any) {
    try {
      const response = await apiClient.put(`/api/reviews/${reviewId}`, updates);
      return response.data;
  }

  static async deleteReview(reviewId: string) {
    try {
      const response = await apiClient.delete(`/api/reviews/${reviewId}`);
      return response;
  }

  static async markReviewHelpful(reviewId: string) {
    try {
      const response = await apiClient.post(`/api/reviews/${reviewId}/helpful`);
      return response.data;
  }

  static async getUserReviews(limit = 50) {
    try {
      const response = await apiClient.get(`/api/reviews/user/reviews?limit=${limit}`);
      return response.data;
  }

  static async moderateReview(reviewId: string, status: 'approved' | 'rejected') {
    try {
      const response = await apiClient.put(`/api/reviews/${reviewId}/status`, { status });
      return response.data;
  }
}

// ==========================================
// ANALYTICS & DASHBOARD
// ==========================================

export class AnalyticsService {
  static async getDashboardAnalytics(period = '30d') {
    try {
      const response = await apiClient.get(`/api/analytics/dashboard?period=${period}`);
      return response.data;
  }

  static async getArtisanAnalytics(period = '30d') {
    try {
      const response = await apiClient.get(`/api/analytics/artisan?period=${period}`);
      return response.data;
  }

  static async getBuyerAnalytics() {
    try {
      const response = await apiClient.get('/api/analytics/buyer');
      return response.data;
  }
}

// ==========================================
// AI ASSISTANT
// ==========================================

export class AIAssistantService {
  static async generateProductDescription(productData: any) {
    try {
      const response = await apiClient.post('/api/ai/product-description', productData);
      return response.data;
  }

  static async generatePricing(productData: any) {
    try {
      const response = await apiClient.post('/api/ai/product-pricing', productData);
      return response.data;
  }

  static async generateArtisanBio(artisanData: any) {
    try {
      const response = await apiClient.post('/api/ai/artisan-bio', artisanData);
      return response.data;
  }

  static async categorizeProduct(productData: any) {
    try {
      const response = await apiClient.post('/api/ai/product-categorization', productData);
      return response.data;
  }

  static async getMarketInsights(category?: string, location?: string) {
    try {
      const params = new URLSearchParams();
      if (category) params.append('category', category);
      if (location) params.append('location', location);

      const response = await apiClient.get(`/api/ai/market-insights?${params.toString()}`);
      return response.data;
  }

  static async getRecommendations(limit = 10) {
    try {
      const response = await apiClient.get(`/api/ai/recommendations?limit=${limit}`);
      return response.data;
  }
}

// ==========================================
// FILE UPLOAD SERVICE
// ==========================================

export class FileService {
  static async uploadFile(file: File, type: 'product-image' | 'profile-image' | 'portfolio' | 'general' = 'general') {
    try {
      const formData = new FormData();
      formData.append('file', file);

      const token = localStorage.getItem('culturecart_token');
      const response = await fetch(`${API_BASE_URL}/api/uploads/single`, {
        method: 'POST',
        headers: {
          ...(token && { Authorization: `Bearer ${token}` }),
        },
        body: formData,
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || 'Upload failed');
      }

      return data.data;
  }

  static async uploadMultipleFiles(files: File[], type: 'product-images' | 'portfolio' = 'product-images') {
    try {
      const formData = new FormData();
      files.forEach(file => formData.append('files', file));

      const endpoint = type === 'product-images' ? '/api/uploads/product-images' : '/api/uploads/portfolio';
      const token = localStorage.getItem('culturecart_token');

      const response = await fetch(`${API_BASE_URL}${endpoint}`, {
        method: 'POST',
        headers: {
          ...(token && { Authorization: `Bearer ${token}` }),
        },
        body: formData,
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || 'Upload failed');
      }

      return data.data;
  }

  static async deleteFile(filename: string) {
    try {
      const response = await apiClient.delete(`/api/uploads/${filename}`);
      return response;
  }

  static async getUploadStats() {
    try {
      const response = await apiClient.get('/api/uploads/stats');
      return response.data;
  }
}

// Export all services
export { apiClient };
